import process from 'process'
import { Metadata, credentials } from '@grpc/grpc-js'
import { Resource } from '@opentelemetry/resources'
import { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions'
import {
  BasicTracerProvider,
  ConsoleSpanExporter,
  SimpleSpanProcessor,
} from '@opentelemetry/sdk-trace-base'
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-grpc'
import { warn } from '../../build/output/log'
import { context, Span, trace as traceApi, TraceAPI } from '@opentelemetry/api'

// Pseudo interface to return dynamically configured trace options to create global tracer.
// `traceExporter`, and `metricsExporter` is something user should be able to configure for their own trace backend.
const getTraceOptions = () => {
  // Metadata is passed into to the tracer to provide both the dataset name and the api key reuired for Honeycomb
  const metadata = new Metadata()
  metadata.set('x-honeycomb-team', process.env.HONEYCOMB_TEAM!) // api key, should not be included in code
  metadata.set('x-honeycomb-dataset', 'next-trace-poc')

  // The Trace Exporter exports the data to Honeycomb by providing the metadata + url information
  const traceExporter = new OTLPTraceExporter({
    url: 'grpc://api.honeycomb.io:443/',
    credentials: credentials.createSsl(),
    metadata,
  })

  return {
    // The service name is passed using a the resource package
    // which is an attribute that apply to all spans generated by a process.
    serviceName: 'nextjs-app-poc',
    traceExporter,
    debug: true,
  }
}

/**
 * Initialize the OpenTelemetry APIs to use the BasicTracerProvider bindings.
 *
 * This registers the tracer provider with the OpenTelemetry API as the global
 * tracer provider. This means when you call API methods like
 * `opentelemetry.trace.getTracer`, they will use this tracer provider. If you
 * do not register a global tracer provider, instrumentation which calls these
 * methods will receive no-op implementations.
 */
export const initializeTraceOnce = (() => {
  let provider: BasicTracerProvider

  return () => {
    if (!!provider) {
      return
    }
    const { serviceName, traceExporter, debug } = getTraceOptions()
    // Creating a provider from base trace. We do not do any automatic instrumentation,
    // does not require to use `@opentelemetry/node-sdk`
    provider = new BasicTracerProvider({
      resource: new Resource({
        [SemanticResourceAttributes.SERVICE_NAME]: serviceName,
      }),
    })

    provider.addSpanProcessor(new SimpleSpanProcessor(traceExporter))
    if (debug) {
      provider.addSpanProcessor(
        new SimpleSpanProcessor(new ConsoleSpanExporter())
      )
    }

    provider.register()

    process.on('SIGTERM', () => {
      if (provider) {
        provider.shutdown().then(
          () => {
            provider = null as any
          },
          (e) => {
            warn('Failed to terminate trace', e.toString())
          }
        )
      }
    })
  }
})()

/// Provides interfaces to the initialized trace instance to create trace spans in a wrapped way, instead of manually creating it per each,.
/// No-op for now: this is a proposed api, not an actual implementation yet.
class Tracer {
  constructor(private readonly _trace: TraceAPI) {}

  /**
   * Instruments a function by automatically creating a span activated on its
   * scope.
   *
   * The span will automatically be finished when one of these conditions is
   * met:
   *
   * * The function returns a promise, in which case the span will finish when
   * the promise is resolved or rejected.
   * * The function takes a callback as its second parameter, in which case the
   * span will finish when that callback is called.
   * * The function doesn't accept a callback and doesn't return a promise, in
   * which case the span will finish at the end of the function execution.
   *
   */
  public trace<T>(
    name: string,
    fn: (span?: Span, fnCb?: (error?: Error) => any) => T
  ): T
  public trace<T>(
    name: string,
    options: unknown,
    fn: (span?: Span, done?: (error?: Error) => string) => T
  ): T
  public trace(...args: Array<any>) {
    // https://nodejs.org/docs/latest-v14.x/api/async_hooks.html
    throw new Error('not implemented')
  }

  /**
   * Wrap a function to automatically create a span activated on its
   * scope when it's called.
   *
   * The span will automatically be finished when one of these conditions is
   * met:
   *
   * * The function returns a promise, in which case the span will finish when
   * the promise is resolved or rejected.
   * * The function takes a callback as its last parameter, in which case the
   * span will finish when that callback is called.
   * * The function doesn't accept a callback and doesn't return a promise, in
   * which case the span will finish at the end of the function execution.
   */
  public wrap<T = (...args: Array<any>) => any>(name: string, fn: T): T
  public wrap<T = (...args: Array<any>) => any>(
    name: string,
    options: unknown,
    fn: T
  ): T
  public wrap<T = (...args: Array<any>) => any>(
    name: string,
    options: (...args: any[]) => unknown,
    fn: T
  ): T
  public wrap(...args: Array<any>) {
    // https://nodejs.org/docs/latest-v14.x/api/async_hooks.html
    throw new Error('not implemented')
  }
}

export const getTracer = (name: string = 'next-poc') => {
  return traceApi.getTracer(name)
}

export const startSpan = (spanName: string, parentSpan?: Span) => {
  const ctx = parentSpan
    ? traceApi.setSpan(context.active(), parentSpan)
    : undefined
  return getTracer().startSpan(spanName, undefined, ctx)
}
